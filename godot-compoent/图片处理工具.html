<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片处理工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        
        .upload-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .upload-section input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #2980b9;
        }
        
        .controls {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input {
            padding: 8px;
            width: 100px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .merge-btn {
            background-color: #9b59b6;
            color: white;
        }
        
        .merge-btn:hover {
            background-color: #7e22ce;
        }
        
        .sort-btn {
            background-color: #0ea5e9;
        }
        
        .sort-btn:hover {
            background-color: #0284c7;
        }
        
        .select-btn {
            background-color: #22c55e;
        }
        
        .select-btn:hover {
            background-color: #16a34a;
        }
        
        .frame-name {
            cursor: pointer;
            border-bottom: 1px dashed #9ca3af;
        }
        
        .frame-name:hover {
            border-bottom: 1px solid #0ea5e9;
            color: #0ea5e9;
        }
        
        .rename-input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #3b82f6;
            border-radius: 4px;
            font-size: 12px;
            box-sizing: border-box;
        }
        
        /* 宫格合并预览区域 */
        .grid-preview-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .grid-preview-container {
            background-color: #000;
            border: 2px solid #ddd;
            border-radius: 4px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .grid-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .grid-inputs label {
            font-weight: bold;
        }
        
        .grid-inputs input {
            width: 60px;
            padding: 5px;
            text-align: center;
        }
        
        .align-btn {
            background-color: #2ecc71;
            color: white;
        }
        
        .resize-btn {
            background-color: #f39c12;
            color: white;
        }
        
        .download-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .align-btn:hover {
            background-color: #27ae60;
        }
        
        .resize-btn:hover {
            background-color: #e67e22;
        }
        
        .download-btn:hover {
            background-color: #c0392b;
        }

        /* 视频转帧图相关样式 */
        .video-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .video-section h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .video-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: flex-end;
        }

        .video-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .video-control-group label {
            font-weight: bold;
            font-size: 14px;
        }

        .video-control-group input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .video-control-group input[type="number"] {
            width: 100px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .video-control-group small {
            font-size: 12px;
            color: #666;
        }

        .video-preview {
            margin-bottom: 20px;
            text-align: center;
        }

        #video-preview {
            max-width: 100%;
            max-height: 400px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        #video-info {
            color: #666;
            font-size: 14px;
        }

        #frame-preview-section h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .frame-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .frame-item {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            background-color: #f9f9f9;
        }

        .frame-item img {
            max-width: 150px;
            max-height: 150px;
            object-fit: contain;
            margin-bottom: 10px;
            border: 1px solid #eee;
        }

        .frame-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .frame-download-btn {
            padding: 5px 10px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .frame-download-btn:hover {
            background-color: #c0392b;
        }

        #download-frames-btn {
            background-color: #3498db;
            color: white;
        }

        #download-frames-btn:hover {
            background-color: #2980b9;
        }

        #download-zip-btn {
            background-color: #9b59b6;
            color: white;
        }

        #download-zip-btn:hover {
            background-color: #8e44ad;
        }
        
        .frame-info {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 2px;
        }
        
        .preview-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 200px;
        }
        
        .animation-preview {
            background-color: #000;
            border: 2px solid #ddd;
            border-radius: 4px;
            display: none;
        }
        
        .animation-preview img.active {
            display: block;
        }
        
        .animation-controls {
            margin-top: 10px;
            text-align: center;
        }
        
        .frames-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .frame-item {
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .frame-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .frame-preview {
            width: 100%;
            height: 120px;
            background-color: #f0f0f0;
            border: 1px dashed #ccc;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .frame-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .center-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: block; /* 默认显示中心点 */
        }
        
        .frame-item.selected .frame-preview {
            border-color: #3498db;
            border-width: 2px;
        }
        
        .frame-item.selected .center-point {
            display: block;
        }
        
        .frame-name {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            word-break: break-all;
        }
        
        .fps-control {
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .frames-container {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .action-btn {
                width: 100%;
            }
        }
        /* 编辑模态框样式 - 全屏显示 */
        .edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            display: none;
        }
        
        .edit-modal-content {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            color: white;
        }
        
        .edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid #555;
        }
        
        .edit-modal-header h3 {
            margin: 0;
            color: white;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: white;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            color: #ff6b6b;
        }
        
        /* 缩放控制 */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .zoom-btn {
            background-color: #333;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 18px;
        }
        
        .zoom-btn:hover {
            background-color: #555;
        }
        
        .zoom-level {
            color: white;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }
        
        .edit-modal-body {
            flex: 1;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background-color: #000;
        }
        
        .edit-canvas-container {
            position: relative;
            background-color: #000;
            border: none;
            cursor: grab;
            overflow: visible;
        }
        
        .edit-canvas-container:active {
            cursor: grabbing;
        }
        
        #edit-canvas {
            display: block;
            cursor: crosshair;
        }
        
        .edit-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
        }
        
        /* 操作提示 */
        .operation-hints {
            position: fixed;
            top: 80px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 200px;
        }
        
        .edit-modal-footer {
            padding: 15px 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-top: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .center-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .center-controls input[type="number"] {
            padding: 5px 8px;
            border: 1px solid #555;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
        }
        
        .center-controls input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .center-controls span {
             color: white;
             font-size: 14px;
         }
        </style>
    <!-- 直接引入JSZip库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>图片处理工具</h1>

        <div class="upload-section">
            <label for="file-upload" class="upload-btn">
                选择图片文件 (支持多选)
            </label>
            <input type="file" id="file-upload" accept="image/*" multiple>
            <p id="file-info" style="margin-top: 10px;"></p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>批量裁剪图片：</label>
                <input type="number" id="width-input" placeholder="宽度">
                <input type="number" id="height-input" placeholder="高度">
                <button class="action-btn resize-btn" onclick="cropImages()">裁剪图片</button>
            </div>
            
            <div class="control-group">
                <div class="grid-inputs">
                    <label>宫格合并：</label>
                    <input type="number" id="grid-rows" min="1" max="10" value="2" placeholder="行数">
                    <label>×</label>
                    <input type="number" id="grid-cols" min="1" max="10" value="2" placeholder="列数">
                    <button class="action-btn merge-btn" onclick="previewGridMerge()">预览宫格</button>
                    <button class="action-btn merge-btn" onclick="downloadGridImage()">导出宫格</button>
                </div>
            </div>
            
            <div class="control-group">
                <button class="action-btn align-btn" onclick="alignImagesByCenter()">按中心点对齐</button>
                <button class="action-btn download-btn" onclick="downloadAllImages()">下载所有图片</button>
                <button class="action-btn sort-btn" onclick="sortImagesByName()">按名称排序</button>
                <button class="action-btn select-btn" onclick="selectAllImages()">全选</button>
                <button class="action-btn select-btn" onclick="invertImageSelection()">反选</button>
            </div>
        </div>
        
        <!-- 宫格合并预览区域 -->
        <div class="grid-preview-section" id="grid-preview-section">
            <h3>宫格合并预览</h3>
            <div class="grid-preview-container" id="grid-preview-container">
                <div id="grid-placeholder">请点击预览按钮查看宫格效果</div>
                <img id="grid-preview-img" style="display: none; max-width: 100%; max-height: 300px;">
            </div>
        </div>
        
        <div class="preview-section">
            <h3>动画预览</h3>
            <div class="animation-preview" id="animation-preview">
                <div id="preview-placeholder">请上传图片以预览动画</div>
                <!-- 图片将在这里动态加载 -->
            </div>
            <div class="animation-controls">
                <label>帧速率 (FPS): </label>
                <input type="number" id="fps-input" value="10" min="1" max="60">
                <button class="action-btn" onclick="startAnimation()">播放</button>
                <button class="action-btn" onclick="stopAnimation()">停止</button>
            </div>
        </div>
        
        <h3>图片列表</h3>
        <p>点击图片设置中心点，红色圆点表示当前设置的中心点</p>
        <div class="frames-container" id="frames-container">
            <!-- 图片帧将在这里动态加载 -->
        </div>
    </div>
    
    <!-- 大图编辑模态框 - 全屏模式 -->
    <div class="edit-modal" id="edit-modal">
        <div class="edit-modal-content">
            <div class="edit-modal-header">
                <h3>编辑图片中心点</h3>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomOut()">−</button>
                    <span class="zoom-level" id="zoom-level">100%</span>
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                </div>
                <button class="close-btn" onclick="closeEditModal()">×</button>
            </div>
            <div class="edit-modal-body">
                <div class="operation-hints">
                    <div>操作提示：</div>
                    <div>• 点击图片设置中心点</div>
                    <div>• 滚轮缩放图片</div>
                    <div>• 拖拽移动图片</div>
                    <div>• 双击恢复原始大小</div>
                </div>
                <div class="edit-canvas-container" id="edit-canvas-container">
                    <canvas id="edit-canvas"></canvas>
                </div>
                <div class="edit-info">
                    <p>点击图片设置中心点，图片显示九宫格网格</p>
                    <p id="edit-image-info"></p>
                </div>
            </div>
            <div class="edit-modal-footer">
                <div class="center-controls">
                    <span>中心点坐标: </span>
                    <input type="number" id="center-x-input" placeholder="X" min="0" style="width: 60px;">
                    <input type="number" id="center-y-input" placeholder="Y" min="0" style="width: 60px;">
                    <button class="action-btn" onclick="setCenterByInput()">设置</button>
                    <button class="action-btn" onclick="resetCenterPoint()">重置中心点</button>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span>当前坐标: </span>
                        <span id="current-center-coords" style="background: rgba(255,255,255,0.1); padding: 2px 8px; cursor: pointer; border-radius: 3px;" onclick="copyCenterCoords()">-- , --</span>
                        <span id="copy-notice" style="display: none; color: #2ecc71; font-size: 12px;">已复制!</span>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="action-btn align-btn" onclick="resetZoom()">重置视图</button>
                    <button class="action-btn align-btn" onclick="saveCenterPoint()">保存</button>
                    <button class="action-btn align-btn" onclick="applyCenterToAllImages()" style="background-color: #e74c3c;">应用到所有图片</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 存储图片数据
        let imagesData = [];
        let animationInterval = null;
        let currentFrameIndex = 0;
        // 大图编辑相关变量
        let selectedImageData = null;
        let editCanvas = null;
        let editCtx = null;
        let editModal = null;
        let editCanvasContainer = null;
        let currentImage = null;
        let currentScale = 1;
        let scaleStep = 0.1;
        let minScale = 0.1;
        let maxScale = 5;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let offsetX = 0;
        let offsetY = 0;
        
        // 文件上传处理
        document.getElementById('file-upload').addEventListener('change', handleFileUpload);
        
        // 初始化大图编辑相关
        function initEditMode() {
            editModal = document.getElementById('edit-modal');
            editCanvas = document.getElementById('edit-canvas');
            editCtx = editCanvas.getContext('2d');
            editCanvasContainer = document.getElementById('edit-canvas-container');
            
            // 初始化坐标输入框的粘贴功能
            initCoordsInputPaste();
            
            // 点击画布设置中心点
            editCanvas.addEventListener('click', handleCanvasClick);
            
            // 滚轮缩放
            editCanvas.addEventListener('wheel', handleWheelZoom);
            
            // 拖拽移动
            editCanvas.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            
            // 双击重置缩放
            editCanvas.addEventListener('dblclick', resetZoom);
            
            // 点击模态框外部关闭
            editModal.addEventListener('click', (e) => {
                if (e.target === editModal) {
                    closeEditModal();
                }
            });
        }
        
        // 初始化函数
        window.onload = function() {
            initEditMode();
        };
        
        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            document.getElementById('file-info').textContent = `已选择 ${files.length} 个文件`;
            
            // 清空现有数据
            imagesData = [];
            const framesContainer = document.getElementById('frames-container');
            framesContainer.innerHTML = '';
            
            // 处理每个文件
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // 创建图片数据对象，默认中心点为图片中心，默认选中
            const imageData = {
                id: index,
                name: file.name,
                src: e.target.result,
                width: img.width,
                height: img.height,
                centerX: img.width / 2, // 默认设置为图片中心
                centerY: img.height / 2,
                originalWidth: img.width,
                originalHeight: img.height,
                selected: true // 添加选中状态，默认为true
            };
                        
                        imagesData.push(imageData);
                        createFrameItem(imageData);
                        updatePreviewImages();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // 创建图片帧项
        function createFrameItem(imageData) {
            const framesContainer = document.getElementById('frames-container');
            
            const frameItem = document.createElement('div');
            frameItem.className = 'frame-item';
            frameItem.dataset.id = imageData.id;
            
            // 添加选中状态样式
            if (!imageData.selected) {
                frameItem.style.opacity = '0.6';
                frameItem.style.filter = 'grayscale(50%)';
            }
            
            const framePreview = document.createElement('div');
            framePreview.className = 'frame-preview';
            framePreview.onclick = (e) => openEditModal(imageData.id);
            
            const img = document.createElement('img');
            img.src = imageData.src;
            
            const centerPoint = document.createElement('div');
            centerPoint.className = 'center-point';
            centerPoint.style.left = `${(imageData.centerX / imageData.width) * 100}%`;
            centerPoint.style.top = `${(imageData.centerY / imageData.height) * 100}%`;
            
            framePreview.appendChild(img);
            framePreview.appendChild(centerPoint);
            frameItem.appendChild(framePreview);
            
            // 添加勾选开关（移到图片下方）
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'checkbox-container';
            checkboxContainer.style.display = 'flex';
            checkboxContainer.style.justifyContent = 'center';
            checkboxContainer.style.marginTop = '5px';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = imageData.selected;
            checkbox.style.width = '20px';
            checkbox.style.height = '20px';
            checkbox.style.cursor = 'pointer';
            checkbox.onchange = (e) => {
                e.stopPropagation(); // 阻止事件冒泡，避免触发编辑模态框
                imageData.selected = checkbox.checked;
                
                // 更新样式
                if (imageData.selected) {
                    frameItem.style.opacity = '1';
                    frameItem.style.filter = 'grayscale(0%)';
                } else {
                    frameItem.style.opacity = '0.6';
                    frameItem.style.filter = 'grayscale(50%)';
                }
                
                // 更新预览
                updatePreviewImages();
            };
            
            checkboxContainer.appendChild(checkbox);
            frameItem.appendChild(checkboxContainer);
            
            const frameName = document.createElement('div');
            frameName.className = 'frame-name';
            frameName.textContent = imageData.name;
            
            // 添加点击事件进入编辑模式
            frameName.addEventListener('click', function() {
                const currentText = frameName.textContent;
                
                // 创建输入框
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'rename-input';
                input.value = currentText;
                
                // 替换文本为输入框
                frameName.parentNode.replaceChild(input, frameName);
                
                // 自动聚焦并选择所有文本
                input.focus();
                input.select();
                
                // 处理失去焦点
                input.addEventListener('blur', function() {
                    handleRename(imageData.id, input.value.trim() || currentText);
                });
                
                // 处理回车键
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        input.blur();
                    } else if (e.key === 'Escape') {
                        input.parentNode.replaceChild(frameName, input);
                    }
                });
            });
            
            const frameInfo = document.createElement('div');
            frameInfo.className = 'frame-info';
            frameInfo.textContent = `${imageData.width} × ${imageData.height}px`;
            
            frameItem.appendChild(frameName);
            frameItem.appendChild(frameInfo);
            
            framesContainer.appendChild(frameItem);
        }
        
        // 打开大图编辑模态框
        function openEditModal(imageId) {
            // 查找对应的图片数据
            selectedImageData = imagesData.find(img => img.id === imageId);
            if (!selectedImageData) return;
            
            // 重置视图状态
            currentScale = 1;
            offsetX = 0;
            offsetY = 0;
            
            // 更新图片信息
            document.getElementById('edit-image-info').textContent = 
                `文件名: ${selectedImageData.name} | 尺寸: ${selectedImageData.width} × ${selectedImageData.height}px`;
            document.getElementById('zoom-level').textContent = '100%';
            
            // 更新中心点坐标显示
            updateCenterPointDisplay();
            
            // 更新输入框的值
            document.getElementById('center-x-input').value = Math.round(selectedImageData.centerX);
            document.getElementById('center-y-input').value = Math.round(selectedImageData.centerY);
            
            // 加载并显示图片
            currentImage = new Image();
            currentImage.onload = function() {
                // 设置画布尺寸为图片原始尺寸
                editCanvas.width = currentImage.width;
                editCanvas.height = currentImage.height;
                
                // 初始居中显示
                centerCanvas();
                
                // 绘制图片和网格
                drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
            };
            currentImage.src = selectedImageData.src;
            
            // 显示模态框
            editModal.style.display = 'flex';
        }
        
        // 关闭大图编辑模态框
        function closeEditModal() {
            editModal.style.display = 'none';
            selectedImageData = null;
            currentImage = null;
        }
        
        // 居中显示画布
        function centerCanvas() {
            const container = editCanvasContainer;
            const containerRect = container.getBoundingClientRect();
            
            // 计算居中偏移量 - 考虑缩放后的尺寸
            // 注意：由于transform现在是先缩放后平移，平移值需要除以缩放比例
            offsetX = (containerRect.width - editCanvas.width * currentScale) / 2;
            offsetY = (containerRect.height - editCanvas.height * currentScale) / 2;
            
            // 应用偏移
            updateCanvasTransform();
        }
        
        // 更新画布变换
        function updateCanvasTransform() {
            // 使用左上角作为变换原点(0, 0)，这与我们的坐标计算逻辑保持一致
            editCanvas.style.transformOrigin = '0 0';
            // 先应用缩放，再应用平移，这是CSS transform的正确顺序
            editCanvas.style.transform = `scale(${currentScale}) translate(${offsetX / currentScale}px, ${offsetY / currentScale}px)`;
            document.getElementById('zoom-level').textContent = `${Math.round(currentScale * 100)}%`;
        }
        
        // 放大
        function zoomIn() {
            if (currentScale < maxScale) {
                currentScale = Math.min(currentScale + scaleStep, maxScale);
                updateCanvasTransform();
                if (currentImage) {
                    drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
                }
            }
        }
        
        // 缩小
        function zoomOut() {
            if (currentScale > minScale) {
                currentScale = Math.max(currentScale - scaleStep, minScale);
                updateCanvasTransform();
                if (currentImage) {
                    drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
                }
            }
        }
        
        // 重置缩放
        function resetZoom() {
            currentScale = 1;
            centerCanvas();
            if (currentImage) {
                drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
            }
        }
        
        // 处理滚轮缩放
        function handleWheelZoom(e) {
            e.preventDefault();
            
            // 获取鼠标在容器中的位置
            const container = editCanvasContainer;
            const containerRect = container.getBoundingClientRect();
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            // 记录缩放前的鼠标位置（相对于原始图片坐标系）
            const oldImageX = (mouseX - offsetX) / currentScale;
            const oldImageY = (mouseY - offsetY) / currentScale;
            
            // 保存当前缩放比例用于计算
            const oldScale = currentScale;
            
            // 根据滚轮方向缩放
            if (e.deltaY < 0) {
                if (currentScale < maxScale) {
                    currentScale = Math.min(currentScale + scaleStep, maxScale);
                }
            } else {
                if (currentScale > minScale) {
                    currentScale = Math.max(currentScale - scaleStep, minScale);
                }
            }
            
            // 更新画布变换
            updateCanvasTransform();
            
            // 调整偏移量，使缩放围绕鼠标位置进行
            // 计算鼠标在新缩放比例下应该对应的容器位置
            const newOffsetX = mouseX - (oldImageX * currentScale);
            const newOffsetY = mouseY - (oldImageY * currentScale);
            
            offsetX = newOffsetX;
            offsetY = newOffsetY;
            
            updateCanvasTransform();
            
            // 重新绘制图片和网格
            if (currentImage && selectedImageData) {
                drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
            }
        }
        
        // 开始拖拽
        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }
        
        // 拖拽移动
        function drag(e) {
            if (!isDragging) return;
            
            // 计算鼠标移动的距离
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            // 更新偏移量 - 直接加上鼠标移动的距离
            // 注意：由于我们现在先缩放后平移，平移值不需要再考虑缩放因子
            offsetX += dx;
            offsetY += dy;
            
            // 更新画布变换
            updateCanvasTransform();
            
            // 更新鼠标位置
            lastX = e.clientX;
            lastY = e.clientY;
        }
        
        // 结束拖拽
        function endDrag() {
            isDragging = false;
        }
        
        // 保存中心点设置
        function saveCenterPoint() {
            // 更新小图中的中心点显示
            updateFrameItems();
            updatePreviewImages();
            closeEditModal();
        }
        
        // 将当前中心点应用到所有图片
        function applyCenterToAllImages() {
            if (selectedImageData !== null && currentImage) {
                // 获取当前编辑图片的中心点坐标
                const currentCenterX = selectedImageData.centerX;
                const currentCenterY = selectedImageData.centerY;
                
                // 将中心点应用到所有图片
                for (let i = 0; i < imagesData.length; i++) {
                    imagesData[i].centerX = currentCenterX;
                    imagesData[i].centerY = currentCenterY;
                }
            }
            
            // 更新帧项显示
            updateFrameItems();
            
            // 显示操作成功提示
            showNotification('中心点已应用到所有图片');
        }
        
        // 显示通知提示
        function showNotification(message) {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.position = 'fixed';
            notification.style.top = '50%';
            notification.style.left = '50%';
            notification.style.transform = 'translate(-50%, -50%)';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            notification.style.color = 'white';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '5px';
            notification.style.zIndex = '10000';
            notification.style.fontSize = '16px';
            document.body.appendChild(notification);
            
            // 2秒后移除通知
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }
        
        // 处理图片重命名
        function handleRename(imageId, newName) {
            // 查找对应的图片数据
            const imageIndex = imagesData.findIndex(img => img.id === imageId);
            if (imageIndex === -1) return;
            
            const oldName = imagesData[imageIndex].name;
            
            // 验证名称是否为空或重复
            if (!newName.trim()) {
                showNotification('名称不能为空');
                return;
            }
            
            // 检查是否与其他图片重名
            if (imagesData.some((img, index) => index !== imageIndex && img.name === newName.trim())) {
                showNotification('名称已存在');
                return;
            }
            
            // 更新图片数据
            imagesData[imageIndex].name = newName.trim();
            
            // 更新选中的图片（如果当前选中的是这张图片）
            if (selectedImageData && selectedImageData.id === imageId) {
                selectedImageData.name = newName.trim();
            }
            
            // 更新UI显示
            updateFrameItems();
            
            // 显示成功通知
            if (oldName !== newName) {
                showNotification('图片重命名成功');
            }
        }
        
        // 按名称排序图片
        function sortImagesByName() {
            // 按照图片名称的字母顺序排序（不区分大小写）
            imagesData.sort((a, b) => {
                const nameA = a.name.toLowerCase();
                const nameB = b.name.toLowerCase();
                
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });
            
            // 更新UI显示
            updateFrameItems();
            
            // 显示成功通知
            showNotification('图片已按名称排序');
        }
        
        // 全选功能
        function selectAllImages() {
            // 将所有图片标记为选中
            imagesData.forEach(img => {
                img.selected = true;
            });
            
            // 更新UI显示
            updateFrameItems();
            updatePreviewImages();
            
            // 显示操作成功的通知
            showNotification('已全选所有图片');
        }
        
        // 反选功能
        function invertImageSelection() {
            // 切换所有图片的选中状态
            imagesData.forEach(img => {
                img.selected = !img.selected;
            });
            
            // 更新UI显示
            updateFrameItems();
            updatePreviewImages();
            
            // 显示操作成功的通知
            showNotification('已反选所有图片');
        }
        
        // 重置中心点到图片中心
        function resetCenterPoint() {
            if (!selectedImageData || !currentImage) return;
            
            // 重置中心点到图片中心
            selectedImageData.centerX = currentImage.width / 2;
            selectedImageData.centerY = currentImage.height / 2;
            
            // 更新显示和输入框
            updateCenterPointDisplay();
            document.getElementById('center-x-input').value = Math.round(selectedImageData.centerX);
            document.getElementById('center-y-input').value = Math.round(selectedImageData.centerY);
            
            // 重新绘制
            drawImageWithGrid(currentImage, selectedImageData.centerX, selectedImageData.centerY);
        }
        
        // 通过输入框设置中心点
        function setCenterByInput() {
            if (!selectedImageData || !currentImage) return;
            
            const xInput = document.getElementById('center-x-input');
            const yInput = document.getElementById('center-y-input');
            
            let newX = parseFloat(xInput.value);
            let newY = parseFloat(yInput.value);
            
            // 验证输入
            if (isNaN(newX) || isNaN(newY)) {
                alert('请输入有效的坐标值');
                return;
            }
            
            // 确保坐标在有效范围内
            const validX = Math.max(0, Math.min(newX, currentImage.width));
            const validY = Math.max(0, Math.min(newY, currentImage.height));
            
            // 更新中心点
            selectedImageData.centerX = validX;
            selectedImageData.centerY = validY;
            
            // 更新显示
            updateCenterPointDisplay();
            xInput.value = Math.round(validX);
            yInput.value = Math.round(validY);
            
            // 重新绘制
            drawImageWithGrid(currentImage, validX, validY);
        }
        
        // 复制中心点坐标
        function copyCenterCoords() {
            if (!selectedImageData) return;
            
            // 格式化坐标字符串，保留整数
            const coordsText = `${Math.round(selectedImageData.centerX)}, ${Math.round(selectedImageData.centerY)}`;
            
            // 复制到剪贴板
            navigator.clipboard.writeText(coordsText).then(() => {
                // 显示复制成功提示
                const notice = document.getElementById('copy-notice');
                notice.style.display = 'inline';
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
                // 降级方案：创建临时输入框
                const tempInput = document.createElement('input');
                tempInput.value = coordsText;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                
                // 显示复制成功提示
                const notice = document.getElementById('copy-notice');
                notice.style.display = 'inline';
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 2000);
            });
        }
        
        // 更新中心点坐标显示
        function updateCenterPointDisplay() {
            if (!selectedImageData) {
                document.getElementById('current-center-coords').textContent = '-- , --';
                return;
            }
            
            // 显示整数坐标
            const centerText = `${Math.round(selectedImageData.centerX)}, ${Math.round(selectedImageData.centerY)}`;
            document.getElementById('current-center-coords').textContent = centerText;
        }
        
        // 处理画布点击事件
        function handleCanvasClick(e) {
            if (!selectedImageData || !currentImage) return;
            
            // 关键修复：获取画布容器的边界矩形，而不是画布本身
            const container = editCanvasContainer;
            const containerRect = container.getBoundingClientRect();
            
            // 计算点击位置相对于容器的坐标
            const clickX = e.clientX - containerRect.left;
            const clickY = e.clientY - containerRect.top;
            
            // 正确的坐标转换逻辑：
            // 1. 减去画布在容器中的偏移量
            // 2. 除以当前缩放比例
            // 这样得到的是相对于原始图片的准确坐标
            const imageX = (clickX - offsetX) / currentScale;
            const imageY = (clickY - offsetY) / currentScale;
            
            // 确保坐标在图片有效范围内
            const validX = Math.max(0, Math.min(imageX, selectedImageData.width));
            const validY = Math.max(0, Math.min(imageY, selectedImageData.height));
            
            // 更新中心点坐标
            selectedImageData.centerX = validX;
            selectedImageData.centerY = validY;
            
            // 更新坐标显示和输入框
            updateCenterPointDisplay();
            document.getElementById('center-x-input').value = Math.round(validX);
            document.getElementById('center-y-input').value = Math.round(validY);
            
            // 重新绘制，使用验证后的坐标
            drawImageWithGrid(currentImage, validX, validY);
            
            // 调试信息（可选）
            console.log(`点击坐标: (${clickX}, ${clickY}), 偏移: (${offsetX}, ${offsetY}), 缩放: ${currentScale}, 转换后: (${imageX}, ${imageY}), 有效坐标: (${validX}, ${validY})`);
        }
        
        // 初始化坐标输入框的粘贴功能
        function initCoordsInputPaste() {
            const xInput = document.getElementById('center-x-input');
            const yInput = document.getElementById('center-y-input');
            
            // 为X输入框添加粘贴事件
            xInput.addEventListener('paste', function(e) {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                processPastedCoords(text);
            });
            
            // 为Y输入框添加粘贴事件
            yInput.addEventListener('paste', function(e) {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                processPastedCoords(text);
            });
        }
        
        // 处理粘贴的坐标数据
        function processPastedCoords(text) {
            // 尝试解析坐标格式，支持多种格式："x,y"、"x y"、"(x,y)"等
            const regex = /\d+\.?\d*/g;
            const matches = text.match(regex);
            
            if (matches && matches.length >= 2) {
                const x = parseFloat(matches[0]);
                const y = parseFloat(matches[1]);
                
                if (!isNaN(x) && !isNaN(y)) {
                    // 更新输入框
                    document.getElementById('center-x-input').value = Math.round(x);
                    document.getElementById('center-y-input').value = Math.round(y);
                    
                    // 可选：自动应用坐标
                    setCenterByInput();
                }
            }
        }
        
        // 绘制图片和九宫格网格
        function drawImageWithGrid(img, centerX, centerY) {
            // 清空画布
            editCtx.clearRect(0, 0, editCanvas.width, editCanvas.height);
            
            // 绘制图片（原始尺寸）
            editCtx.drawImage(img, 0, 0, img.width, img.height);
            
            // 确保中心点坐标有效
            const validCenterX = Math.max(0, Math.min(centerX, editCanvas.width));
            const validCenterY = Math.max(0, Math.min(centerY, editCanvas.height));
            
            // 绘制九宫格网格
            editCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            editCtx.lineWidth = 1;
            
            // 绘制垂直线
            editCtx.beginPath();
            editCtx.moveTo(editCanvas.width / 3, 0);
            editCtx.lineTo(editCanvas.width / 3, editCanvas.height);
            editCtx.moveTo(editCanvas.width * 2 / 3, 0);
            editCtx.lineTo(editCanvas.width * 2 / 3, editCanvas.height);
            editCtx.stroke();
            
            // 绘制水平线
            editCtx.beginPath();
            editCtx.moveTo(0, editCanvas.height / 3);
            editCtx.lineTo(editCanvas.width, editCanvas.height / 3);
            editCtx.moveTo(0, editCanvas.height * 2 / 3);
            editCtx.lineTo(editCanvas.width, editCanvas.height * 2 / 3);
            editCtx.stroke();
            
            // 绘制穿过中心点的米字线
            editCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            editCtx.lineWidth = 1;
            
            // 垂直线（穿过中心点）
            editCtx.beginPath();
            editCtx.moveTo(validCenterX, 0);
            editCtx.lineTo(validCenterX, editCanvas.height);
            editCtx.stroke();
            
            // 水平线（穿过中心点）
            editCtx.beginPath();
            editCtx.moveTo(0, validCenterY);
            editCtx.lineTo(editCanvas.width, validCenterY);
            editCtx.stroke();
            
            // 对角线（左上到右下）
            editCtx.beginPath();
            editCtx.moveTo(0, 0);
            editCtx.lineTo(editCanvas.width, editCanvas.height);
            editCtx.stroke();
            
            // 对角线（右上到左下）
            editCtx.beginPath();
            editCtx.moveTo(editCanvas.width, 0);
            editCtx.lineTo(0, editCanvas.height);
            editCtx.stroke();
            
            // 绘制中心点标记
            editCtx.fillStyle = 'red';
            editCtx.beginPath();
            editCtx.arc(validCenterX, validCenterY, 5, 0, Math.PI * 2);
            editCtx.fill();
            
            // 绘制中心点外圈
            editCtx.strokeStyle = 'white';
            editCtx.lineWidth = 2;
            editCtx.beginPath();
            editCtx.arc(validCenterX, validCenterY, 7, 0, Math.PI * 2);
            editCtx.stroke();
        }
        
        // 按中心点对齐图片
        function alignImagesByCenter() {
            if (imagesData.length === 0) {
                alert('请先上传图片');
                return;
            }
            
            // 创建一个新的画布来处理对齐
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 计算需要的总尺寸（基于最大宽度和高度）
            const maxWidth = Math.max(...imagesData.map(img => img.width));
            const maxHeight = Math.max(...imagesData.map(img => img.height));
            
            // 对每个图片进行对齐处理
            imagesData.forEach(imageData => {
                canvas.width = maxWidth;
                canvas.height = maxHeight;
                ctx.clearRect(0, 0, maxWidth, maxHeight);
                
                // 计算新的位置，使中心点对齐
                const newX = (maxWidth / 2) - imageData.centerX;
                const newY = (maxHeight / 2) - imageData.centerY;
                
                // 绘制图片到新位置
                const img = new Image();
                img.src = imageData.src;
                ctx.drawImage(img, newX, newY, imageData.width, imageData.height);
                
                // 更新图片数据
                imageData.src = canvas.toDataURL();
                imageData.width = maxWidth;
                imageData.height = maxHeight;
                imageData.centerX = maxWidth / 2;
                imageData.centerY = maxHeight / 2;
            });
            
            // 更新视图
            updateFrameItems();
            updatePreviewImages();
            
            alert('图片已按中心点对齐');
        }
        
        // 批量裁剪图片
        function cropImages() {
            const width = parseInt(document.getElementById('width-input').value);
            const height = parseInt(document.getElementById('height-input').value);
            
            if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                alert('请输入有效的宽度和高度');
                return;
            }
            
            if (imagesData.length === 0) {
                alert('请先上传图片');
                return;
            }
            
            // 创建画布进行裁剪
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // 裁剪每个图片
            imagesData.forEach(imageData => {
                // 计算裁剪区域，以中心点为基准
                const cropX = Math.max(0, imageData.centerX - width / 2);
                const cropY = Math.max(0, imageData.centerY - height / 2);
                
                // 确保裁剪区域不超出原图范围
                const actualCropX = Math.min(cropX, imageData.width - width);
                const actualCropY = Math.min(cropY, imageData.height - height);
                
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                // 绘制裁剪区域
                const img = new Image();
                img.src = imageData.src;
                ctx.drawImage(img, actualCropX, actualCropY, width, height, 0, 0, width, height);
                
                // 更新图片数据
                imageData.src = canvas.toDataURL();
                imageData.width = width;
                imageData.height = height;
                // 中心点相对于裁剪后的图片保持在中心位置
                imageData.centerX = width / 2;
                imageData.centerY = height / 2;
            });
            
            // 更新视图
            updateFrameItems();
            updatePreviewImages();
            
            alert('图片已裁剪完成');
        }
        
        // 更新帧项视图
        function updateFrameItems() {
            const framesContainer = document.getElementById('frames-container');
            framesContainer.innerHTML = '';
            
            imagesData.forEach(imageData => {
                createFrameItem(imageData);
            });
        }
        
        // 更新预览图片
        function updatePreviewImages() {
            const previewContainer = document.getElementById('animation-preview');
            previewContainer.innerHTML = '';
            
            // 获取选中的图片
            let selectedImages = imagesData.filter(img => img.selected);
            
            // 按照图片名称排序选中的图片（与sortImagesByName保持一致的排序逻辑）
            selectedImages.sort((a, b) => {
                const nameA = a.name.toLowerCase();
                const nameB = b.name.toLowerCase();
                
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });
            
            if (imagesData.length === 0) {
                const placeholder = document.createElement('div');
                placeholder.id = 'preview-placeholder';
                placeholder.textContent = '请上传图片以预览动画';
                previewContainer.appendChild(placeholder);
                return;
            }
            
            if (selectedImages.length === 0) {
                const placeholder = document.createElement('div');
                placeholder.id = 'preview-placeholder';
                placeholder.textContent = '请至少选择一张图片以预览动画';
                previewContainer.appendChild(placeholder);
                return;
            }
            
            // 创建预览图片
            selectedImages.forEach((imageData, index) => {
                const img = document.createElement('img');
                img.src = imageData.src;
                img.alt = `帧 ${index + 1}`;
                if (index === 0) {
                    img.classList.add('active');
                }
                previewContainer.appendChild(img);
            });
        }
        
        // 开始动画预览
        function startAnimation() {
            // 获取选中的图片
            const selectedImages = imagesData.filter(img => img.selected);
            
            if (imagesData.length === 0) {
                alert('请先上传图片');
                return;
            }
            
            if (selectedImages.length === 0) {
                alert('请至少选择一张图片以播放动画');
                return;
            }
            
            // 停止之前的动画
            stopAnimation();
            
            const fps = parseInt(document.getElementById('fps-input').value) || 10;
            const intervalTime = 1000 / fps;
            
            animationInterval = setInterval(() => {
                const previewContainer = document.getElementById('animation-preview');
                const images = previewContainer.querySelectorAll('img');
                
                // 隐藏所有图片
                images.forEach(img => img.classList.remove('active'));
                
                // 显示当前帧
                images[currentFrameIndex].classList.add('active');
                
                // 更新索引 - 使用选中图片的数量
                currentFrameIndex = (currentFrameIndex + 1) % selectedImages.length;
            }, intervalTime);
        }
        
        // 停止动画预览
        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            currentFrameIndex = 0;
            
            // 显示第一帧
            const previewContainer = document.getElementById('animation-preview');
            const images = previewContainer.querySelectorAll('img');
            if (images.length > 0) {
                images.forEach(img => img.classList.remove('active'));
                images[0].classList.add('active');
            }
        }
        
        // 下载选中的图片
        function downloadAllImages() {
            if (imagesData.length === 0) {
                alert('请先上传图片');
                return;
            }
            
            // 获取选中的图片
            const selectedImages = imagesData.filter(img => img.selected);
            
            if (selectedImages.length === 0) {
                alert('请至少选择一张图片进行下载');
                return;
            }
            
            // 如果只有一张选中的图片，直接下载
            if (selectedImages.length === 1) {
                downloadImage(selectedImages[0]);
                return;
            }
            
            // 多张选中的图片，逐个下载
            selectedImages.forEach((imageData, index) => {
                setTimeout(() => downloadImage(imageData), index * 100);
            });
            
            alert(`开始下载 ${selectedImages.length} 张选中的图片`);
        }
        
        // 下载单张图片
        function downloadImage(imageData) {
            const link = document.createElement('a');
            link.href = imageData.src;
            link.download = imageData.name;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // 合并图片为宫格布局
        function mergeImagesToGrid(rows, cols) {
            // 获取选中的图片
            const selectedImages = imagesData.filter(img => img.selected);
            if (selectedImages.length === 0) {
                alert('请先选择要合并的图片');
                return null;
            }
            
            // 验证宫格尺寸
            if (rows < 1 || cols < 1 || rows > 10 || cols > 10) {
                alert('行数和列数必须在1-10之间');
                return null;
            }
            
            // 计算需要的最小图片数量
            const totalCells = rows * cols;
            if (selectedImages.length > totalCells) {
                alert(`选中的图片数量(${selectedImages.length})超过了宫格容量(${totalCells})，将只使用前${totalCells}张图片`);
            }
            
            // 等待所有图片加载完成
            return new Promise((resolve, reject) => {
                // 计算每张图片的尺寸（找到最大的图片作为基准）
                let maxWidth = 0;
                let maxHeight = 0;
                const imageObjects = [];
                
                // 加载所有需要的图片
                let loadedCount = 0;
                const neededImages = selectedImages.slice(0, totalCells);
                
                if (neededImages.length === 0) {
                    reject('没有可用的图片');
                    return;
                }
                
                neededImages.forEach((imgData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        // 更新最大尺寸
                        if (img.width > maxWidth) maxWidth = img.width;
                        if (img.height > maxHeight) maxHeight = img.height;
                        
                        imageObjects[index] = img;
                        loadedCount++;
                        
                        // 所有图片加载完成
                        if (loadedCount === neededImages.length) {
                            // 创建画布
                            const canvas = document.createElement('canvas');
                            canvas.width = maxWidth * cols;
                            canvas.height = maxHeight * rows;
                            const ctx = canvas.getContext('2d');
                            
                            // 设置白色背景
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // 绘制图片到宫格中
                            neededImages.forEach((imgData, idx) => {
                                const row = Math.floor(idx / cols);
                                const col = idx % cols;
                                const x = col * maxWidth;
                                const y = row * maxHeight;
                                
                                const img = imageObjects[idx];
                                // 计算图片居中位置
                                const drawX = x + (maxWidth - img.width) / 2;
                                const drawY = y + (maxHeight - img.height) / 2;
                                
                                ctx.drawImage(img, drawX, drawY, img.width, img.height);
                            });
                            
                            resolve(canvas.toDataURL('image/png'));
                        }
                    };
                    img.onerror = () => reject('图片加载失败');
                    img.src = imgData.src;
                });
            });
        }
        
        // 预览宫格合并效果
        async function previewGridMerge() {
            const rows = parseInt(document.getElementById('grid-rows').value) || 2;
            const cols = parseInt(document.getElementById('grid-cols').value) || 2;
            
            try {
                const mergedDataUrl = await mergeImagesToGrid(rows, cols);
                if (mergedDataUrl) {
                    // 显示预览区域
                    const previewSection = document.getElementById('grid-preview-section');
                    previewSection.style.display = 'block';
                    
                    // 更新预览图片
                    const previewImg = document.getElementById('grid-preview-img');
                    previewImg.src = mergedDataUrl;
                    previewImg.style.display = 'block';
                    
                    // 隐藏占位符
                    const placeholder = document.getElementById('grid-placeholder');
                    placeholder.style.display = 'none';
                }
            } catch (error) {
                alert('生成宫格预览失败: ' + error);
            }
        }
        
        // 下载宫格合并图片
        async function downloadGridImage() {
            const rows = parseInt(document.getElementById('grid-rows').value) || 2;
            const cols = parseInt(document.getElementById('grid-cols').value) || 2;
            
            try {
                const mergedDataUrl = await mergeImagesToGrid(rows, cols);
                if (mergedDataUrl) {
                    const link = document.createElement('a');
                    link.href = mergedDataUrl;
                    link.download = `宫格合并_${rows}x${cols}_${new Date().getTime()}.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    alert('宫格图片已下载');
                }
            } catch (error) {
                alert('导出宫格图片失败: ' + error);
            }}
        
        // 视频转帧图功能 - 等待DOM完全加载
        document.addEventListener('DOMContentLoaded', function() {
            // 确保视频转帧图的DOM元素存在
            const videoUpload = document.getElementById('video-upload');
            const videoPreview = document.getElementById('video-preview');
            const videoInfo = document.getElementById('video-info');
            const frameInterval = document.getElementById('frame-interval');
            const startTime = document.getElementById('start-time');
            const endTime = document.getElementById('end-time');
            const extractFramesBtn = document.getElementById('extract-frames-btn');
            const framePreviewSection = document.getElementById('frame-preview-section');
            const frameGrid = document.getElementById('frame-grid');
            const downloadFramesBtn = document.getElementById('download-frames-btn');
            const downloadZipBtn = document.getElementById('download-zip-btn');
            
            // 检查是否所有元素都存在
            if (!videoUpload || !videoPreview || !videoInfo || !frameInterval || 
                !startTime || !endTime || !extractFramesBtn || !framePreviewSection || 
                !frameGrid || !downloadFramesBtn || !downloadZipBtn) {
                console.error('视频转帧图功能所需的DOM元素未找到');
                return;
            }
            
            // 存储提取的帧
            let extractedFrames = [];
            
            // 处理视频上传
            videoUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                // 检查文件类型
                if (!file.type.includes('video/')) {
                    alert('请上传视频文件');
                    return;
                }
                
                // 创建视频URL
                const videoURL = URL.createObjectURL(file);
                videoPreview.src = videoURL;
                videoInfo.textContent = `${file.name} (${formatFileSize(file.size)})`;
                
                // 启用提取按钮
                extractFramesBtn.disabled = false;
                
                // 当视频元数据加载完成后，设置默认结束时间
                videoPreview.onloadedmetadata = function() {
                    if (endTime.value === '0') {
                        endTime.value = Math.floor(videoPreview.duration);
                    }
                };
            }
        });
        
        // 添加进度显示元素
        function addProgressDisplay() {
            const progressContainer = document.createElement('div');
            progressContainer.id = 'extraction-progress';
            progressContainer.style.display = 'none';
            progressContainer.style.marginTop = '10px';
            
            const progressBar = document.createElement('div');
            progressBar.id = 'progress-bar';
            progressBar.style.width = '100%';
            progressBar.style.height = '20px';
            progressBar.style.backgroundColor = '#f0f0f0';
            progressBar.style.borderRadius = '10px';
            progressBar.style.overflow = 'hidden';
            
            const progressFill = document.createElement('div');
            progressFill.id = 'progress-fill';
            progressFill.style.width = '0%';
            progressFill.style.height = '100%';
            progressFill.style.backgroundColor = '#3498db';
            progressFill.style.transition = 'width 0.3s ease';
            
            const progressText = document.createElement('div');
            progressText.id = 'progress-text';
            progressText.style.textAlign = 'center';
            progressText.style.marginTop = '5px';
            progressText.style.fontSize = '14px';
            progressText.style.color = '#666';
            
            progressBar.appendChild(progressFill);
            progressContainer.appendChild(progressBar);
            progressContainer.appendChild(progressText);
            
            // 添加到视频预览下方
            videoPreview.parentNode.appendChild(progressContainer);
        }
        
        // 更新进度显示
        function updateProgress(current, total) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const progressContainer = document.getElementById('extraction-progress');
            
            if (progressFill && progressText && progressContainer) {
                progressContainer.style.display = 'block';
                const percentage = Math.floor((current / total) * 100);
                progressFill.style.width = percentage + '%';
                progressText.textContent = `提取进度: ${percentage}% (${current}/${total} 帧)`;
            }
        }
        
        // 隐藏进度显示
        function hideProgress() {
            const progressContainer = document.getElementById('extraction-progress');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }
        
        // 提取帧图
        extractFramesBtn.addEventListener('click', async function() {
            try {
                // 确保进度显示元素存在
                if (!document.getElementById('extraction-progress')) {
                    addProgressDisplay();
                }
                
                // 清空之前的帧图
                frameGrid.innerHTML = '';
                extractedFrames = [];
                
                const interval = parseFloat(frameInterval.value) || 1;
                let start = parseFloat(startTime.value) || 0;
                let end = parseFloat(endTime.value) || videoPreview.duration;
                
                // 验证时间参数
                if (isNaN(interval) || interval <= 0) {
                    alert('请输入有效的提取间隔');
                    return;
                }
                
                if (start < 0 || end > videoPreview.duration || start >= end) {
                    alert('请输入有效的时间范围');
                    return;
                }
                
                // 估算帧数，用于进度显示
                const estimatedFrames = Math.ceil((end - start) / interval) + 1;
                
                // 显示加载状态
                extractFramesBtn.disabled = true;
                extractFramesBtn.textContent = '提取中...';
                
                // 提取帧图
                extractedFrames = await extractFramesFromVideo(videoPreview, interval, start, end, estimatedFrames);
                
                // 隐藏进度显示
                hideProgress();
                
                // 显示帧图预览
                displayFramePreviews(extractedFrames);
                
                // 显示预览区域
                framePreviewSection.style.display = 'block';
                
                // 滚动到预览区域
                framePreviewSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // 提示用户提取完成
                alert(`成功提取 ${extractedFrames.length} 个帧图`);
            } catch (error) {
                console.error('提取帧图错误:', error);
                alert('提取帧图失败: ' + (error.message || error));
                hideProgress();
            } finally {
                // 恢复按钮状态
                extractFramesBtn.disabled = false;
                extractFramesBtn.textContent = '提取帧图';
            }
        });
        
        // 从视频中提取帧图
        function extractFramesFromVideo(video, interval, startTime, endTime, estimatedFrames) {
            return new Promise((resolve, reject) => {
                try {
                    // 创建canvas用于绘制帧
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 检查浏览器兼容性
                    if (!ctx) {
                        reject(new Error('浏览器不支持Canvas API'));
                        return;
                    }
                    
                    // 设置canvas大小与视频一致
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // 如果视频尺寸过大，进行适当缩放以提高性能
                    const maxDimension = 1280; // 设置最大尺寸
                    if (canvas.width > maxDimension || canvas.height > maxDimension) {
                        const scale = maxDimension / Math.max(canvas.width, canvas.height);
                        canvas.width = Math.floor(canvas.width * scale);
                        canvas.height = Math.floor(canvas.height * scale);
                    }
                    
                    const frames = [];
                    let currentTime = startTime;
                    let frameCount = 0;
                    let seekTimeoutId = null;
                    
                    // 处理视频seek事件
                    video.addEventListener('seeked', onSeeked);
                    
                    // 处理错误事件
                    video.addEventListener('error', onError);
                    
                    function onSeeked() {
                        try {
                            // 清除之前的超时
                            if (seekTimeoutId) {
                                clearTimeout(seekTimeoutId);
                                seekTimeoutId = null;
                            }
                            
                            // 绘制当前帧到canvas
                            ctx.drawImage(
                                video, 
                                0, 0, video.videoWidth, video.videoHeight, 
                                0, 0, canvas.width, canvas.height
                            );
                            
                            // 将canvas转换为DataURL
                            const frameDataUrl = canvas.toDataURL('image/png');
                            frames.push({
                                dataUrl: frameDataUrl,
                                time: currentTime,
                                index: frameCount
                            });
                            
                            // 更新进度
                            updateProgress(frameCount + 1, estimatedFrames);
                            
                            // 增加计数器
                            frameCount++;
                            
                            // 继续提取下一个帧
                            currentTime += interval;
                            if (currentTime <= endTime) {
                                // 设置超时，防止视频seek事件不触发
                                seekTimeoutId = setTimeout(() => {
                                    console.warn('Seek超时，尝试下一个帧');
                                    video.removeEventListener('seeked', onSeeked);
                                    onSeeked(); // 手动调用一次
                                }, 1000); // 1秒超时
                                
                                video.currentTime = currentTime;
                            } else {
                                // 清理事件监听
                                cleanup();
                                // 提取完成
                                resolve(frames);
                            }
                        } catch (error) {
                            cleanup();
                            reject(error);
                        }
                    }
                    
                    function onError() {
                        console.error('视频播放错误:', video.error);
                        cleanup();
                        reject(new Error('视频播放错误'));
                    }
                    
                    function cleanup() {
                        video.removeEventListener('seeked', onSeeked);
                        video.removeEventListener('error', onError);
                        if (seekTimeoutId) {
                            clearTimeout(seekTimeoutId);
                        }
                    }
                    
                    // 开始提取第一帧
                    video.currentTime = startTime;
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // 显示帧图预览
        function displayFramePreviews(frames) {
            frames.forEach(frame => {
                const frameContainer = document.createElement('div');
                frameContainer.className = 'frame-item';
                
                const img = document.createElement('img');
                img.src = frame.dataUrl;
                img.alt = `帧图 ${frame.index + 1} (${frame.time.toFixed(2)}s)`;
                img.style.maxWidth = '150px';
                img.style.maxHeight = '150px';
                img.style.objectFit = 'contain';
                
                const info = document.createElement('div');
                info.className = 'frame-info';
                info.textContent = `帧 ${frame.index + 1}\n${frame.time.toFixed(2)}s`;
                
                // 下载按钮
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'frame-download-btn';
                downloadBtn.textContent = '下载';
                downloadBtn.addEventListener('click', () => downloadFrame(frame));
                
                frameContainer.appendChild(img);
                frameContainer.appendChild(info);
                frameContainer.appendChild(downloadBtn);
                frameGrid.appendChild(frameContainer);
            });
        }
        
        // 下载单个帧图
        function downloadFrame(frame) {
            const link = document.createElement('a');
            link.href = frame.dataUrl;
            link.download = `frame_${frame.index + 1}_${Math.floor(frame.time)}s.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 下载所有帧图
        downloadFramesBtn.addEventListener('click', function() {
            if (extractedFrames.length === 0) {
                alert('没有可下载的帧图');
                return;
            }
            
            // 创建一个zip文件下载
            if (extractedFrames.length > 5) {
                // 如果帧图数量较多，提示用户使用ZIP下载
                if (confirm(`发现 ${extractedFrames.length} 个帧图，是否下载为ZIP文件？`)) {
                    downloadFramesAsZip();
                } else {
                    // 逐个下载
                    extractedFrames.forEach(frame => downloadFrame(frame));
                }
            } else {
                // 帧数较少，直接逐个下载
                extractedFrames.forEach(frame => downloadFrame(frame));
            }
        });
        
        // 下载为ZIP文件
        downloadZipBtn.addEventListener('click', function() {
            if (extractedFrames.length === 0) {
                alert('没有可下载的帧图');
                return;
            }
            
            downloadFramesAsZip();
        });
        
        // 将帧图打包为ZIP下载
        function downloadFramesAsZip() {
            // 询问用户偏好的下载方式
            const downloadMethod = confirm('请选择下载方式：\n\n- 点击确定：ZIP打包下载（推荐，减少文件数量）\n- 点击取消：批量单独下载（可能更兼容某些Windows安全设置）\n\n无论选择哪种方式，如果遇到安全警告，请右键点击文件，在属性中勾选"解除锁定"。');
            
            if (downloadMethod) {
                // ZIP下载方式
                // 常规的ZIP下载流程将继续执行
            } else {
                // 批量单独下载方式
                downloadFramesAsMultipleFiles();
                return; // 终止函数执行，不进入ZIP下载流程
            }
            
            // 检查是否支持使用第三方库
            if (typeof JSZip !== 'undefined') {
                // 如果页面已加载JSZip库
                createZipWithJSZip();
            } else {
                // 不支持ZIP下载时的替代方案
                alert('当前环境不支持ZIP下载功能。请使用"下载所有帧图"按钮逐个下载。');
            }
        }
        
        // 使用JSZip创建ZIP文件（如果可用）
        function createZipWithJSZip() {
            // 显示加载状态
            downloadZipBtn.disabled = true;
            downloadZipBtn.textContent = '打包中...';
            
            try {
                // 创建JSZip实例并设置更友好的中文文件夹名称
                const zip = new JSZip();
                const frameFolder = zip.folder('视频帧图');
                
                // 添加所有帧图到ZIP - 改进版，确保Base64数据正确处理
                extractedFrames.forEach(frame => {
                    // 从DataURL中提取Base64数据
                    const base64Data = frame.dataUrl.split(',')[1];
                    // 使用更友好的中文文件名，避免英文数字混合命名触发安全警告
                    const filename = `帧图_${String(frame.index + 1).padStart(3, '0')}_${Math.floor(frame.time)}秒.png`;
                    
                    // 增强PNG文件的MIME类型和元数据设置，减少安全警告
                    frameFolder.file(filename, base64Data, {
                        base64: true,
                        binary: true,
                        createFolders: true,
                        // 明确指定MIME类型
                        mimeType: 'image/png',
                        // 设置文件创建日期增强可信度
                        date: new Date()
                    });
                });
                
                // 生成ZIP文件 - 使用更可靠的配置
                // 优化ZIP生成和下载流程，使用更安全的Blob处理方法
                // 增强ZIP元数据和安全标记，使用中文注释和优化的压缩配置
                zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: {
                        level: 6
                    },
                    // 使用中文注释，增强文件可识别性和安全性
                    comment: '视频帧图提取工具生成的安全文件，内容为PNG图片',
                    // 添加创建者信息增强可信度
                    created: new Date(),
                    // 使用更标准的编码方式
                }).then(function(zipContent) {
                    // 确保使用正确的MIME类型
                    const zipBlob = new Blob([zipContent], { 
                        type: 'application/zip; charset=binary'
                    });
                    
                    // 创建安全的下载链接
                    const link = document.createElement('a');
                    
                    // 为链接添加更多元数据属性
                    link.rel = 'noopener';
                    link.setAttribute('download', true);
                    
                    // 使用更友好的文件名格式
                    const now = new Date();
                    const dateStr = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
                    const timeStr = `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
                    link.download = `视频帧图_${dateStr}_${timeStr}.zip`;
                    link.title = '视频帧图压缩包';
                    link.setAttribute('aria-label', '下载视频帧图压缩包');
                    
                    // 创建Blob URL并执行下载
                    try {
                        link.href = URL.createObjectURL(zipBlob);
                        
                        // 使用现代下载方法，先隐藏元素再添加到DOM
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        
                        // 使用更可靠的点击方法
                        link.dispatchEvent(new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        }));
                        
                        // 增强的资源清理机制
                        setTimeout(() => {
                            try {
                                document.body.removeChild(link);
                                if (link.href) {
                                    URL.revokeObjectURL(link.href);
                                    link.href = ''; // 确保链接被清除
                                }
                            } catch (cleanupError) {
                                console.warn('资源清理时发生错误:', cleanupError);
                            }
                        }, 1000); // 延长清理时间，确保下载完成
                    } catch (downloadError) {
                        console.error('下载过程中发生错误:', downloadError);
                        alert('文件下载失败，请重试。错误信息: ' + downloadError.message);
                        
                        // 确保错误情况下也进行清理
                        if (link.href) {
                            URL.revokeObjectURL(link.href);
                        }
                    }
                    
                    // 恢复按钮状态
                    downloadZipBtn.disabled = false;
                    downloadZipBtn.textContent = '下载为ZIP';
                    
                    alert('ZIP文件已下载');
                }).catch(function(error) {
                    console.error('生成ZIP文件失败:', error);
                    alert('生成ZIP文件失败: ' + error.message);
                    
                    // 恢复按钮状态
                    downloadZipBtn.disabled = false;
                    downloadZipBtn.textContent = '下载为ZIP';
                });
            } catch (error) {
                console.error('ZIP功能错误:', error);
                alert('ZIP下载功能暂不可用: ' + error.message);
                
                // 恢复按钮状态
                downloadZipBtn.disabled = false;
                downloadZipBtn.textContent = '下载为ZIP';
            }
        }
        
        // JSZip库已经在页面初始化时直接引用，无需动态加载
        function loadJSZipLibrary() {
            return Promise.resolve(window.JSZip);
        }
        // 批量单独下载图片文件的替代方法
        function downloadFramesAsMultipleFiles() {
            try {
                // 显示加载状态
                downloadZipBtn.disabled = true;
                downloadZipBtn.textContent = '下载中...';
                
                // 检查是否有要下载的帧
                if (!extractedFrames || extractedFrames.length === 0) {
                    alert('没有可下载的帧图像。');
                    downloadZipBtn.disabled = false;
                    downloadZipBtn.textContent = '下载为ZIP';
                    return;
                }
                
                // 创建下载计数器
                let downloadCount = 0;
                const maxSimultaneousDownloads = 5; // 限制同时下载数量
                const queue = [...extractedFrames];
                
                // 分批处理下载
                function processDownloadQueue() {
                    // 处理队列中的任务，直到达到最大并发数或队列为空
                    while (downloadCount < maxSimultaneousDownloads && queue.length > 0) {
                        const frame = queue.shift();
                        downloadCount++;
                        
                        // 使用中文文件名
                        const filename = `帧图_${String(frame.index + 1).padStart(3, '0')}_${Math.floor(frame.time)}秒.png`;
                        
                        // 从DataURL中提取Base64数据
                        const base64Data = frame.dataUrl.split(',')[1];
                        const byteCharacters = atob(base64Data);
                        const byteArrays = [];
                        
                        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                            const slice = byteCharacters.slice(offset, offset + 512);
                            const byteNumbers = new Array(slice.length);
                            for (let i = 0; i < slice.length; i++) {
                                byteNumbers[i] = slice.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            byteArrays.push(byteArray);
                        }
                        
                        const blob = new Blob(byteArrays, { type: 'image/png' });
                        const url = URL.createObjectURL(blob);
                        
                        // 创建并触发下载链接
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.rel = 'noopener';
                        link.style.display = 'none';
                        
                        // 下载完成后清理
                        link.onload = function() {
                            setTimeout(() => {
                                try {
                                    URL.revokeObjectURL(url);
                                    downloadCount--;
                                    
                                    // 处理下一批下载
                                    if (queue.length > 0) {
                                        processDownloadQueue();
                                    } else if (downloadCount === 0) {
                                        // 所有下载完成
                                        downloadZipBtn.disabled = false;
                                        downloadZipBtn.textContent = '下载为ZIP';
                                        alert('所有图片已下载完成。如有安全警告，请在文件属性中勾选"解除锁定"。');
                                    }
                                } catch (cleanupError) {
                                    console.warn('清理资源时发生错误:', cleanupError);
                                    // 即使有错误也继续处理队列
                                    downloadCount--;
                                    if (queue.length > 0) {
                                        processDownloadQueue();
                                    } else if (downloadCount === 0) {
                                        downloadZipBtn.disabled = false;
                                        downloadZipBtn.textContent = '下载为ZIP';
                                    }
                                }
                            }, 1000);
                        };
                        
                        // 添加到DOM并触发点击
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                }
                
                // 开始处理下载队列
                processDownloadQueue();
                
                // 确保加载状态最终被重置
                setTimeout(() => {
                    downloadZipBtn.disabled = false;
                    downloadZipBtn.textContent = '下载为ZIP';
                }, 30000); // 30秒后强制重置，防止无限加载状态
                
            } catch (error) {
                console.error('批量下载失败:', error);
                alert('批量下载过程中发生错误，请尝试ZIP下载方式。');
                downloadZipBtn.disabled = false;
                downloadZipBtn.textContent = '下载为ZIP';
            }
        }
        
        // 视频转帧图功能的JavaScript代码已完成
        });
        
        // JavaScript代码结束
    </script>
    
    <!-- 视频转帧图部分 -->
    <div class="video-section">
        <h2>视频转帧图</h2>
        <div class="video-controls">
            <div class="video-control-group">
                <label for="video-upload">选择视频</label>
                <input type="file" id="video-upload" accept="video/*">
            </div>
            <div class="video-control-group">
                <label for="frame-interval">提取间隔（秒）</label>
                <input type="number" id="frame-interval" value="1" min="0.1" step="0.1">
            </div>
            <div class="video-control-group">
                <label for="start-time">开始时间（秒）</label>
                <input type="number" id="start-time" value="0" min="0" step="0.1">
            </div>
            <div class="video-control-group">
                <label for="end-time">结束时间（秒）</label>
                <input type="number" id="end-time" value="0" min="0" step="0.1">
                <small>（0表示视频结束）</small>
            </div>
            <div class="video-control-group">
                <button id="extract-frames-btn" class="action-btn" disabled>提取帧图</button>
            </div>
        </div>
        
        <div class="video-preview">
            <video id="video-preview" controls></video>
            <p id="video-info">请上传视频</p>
        </div>
        
        <div id="frame-preview-section" style="display: none;">
            <h3>帧图预览</h3>
            <div class="frame-grid" id="frame-grid"></div>
            <div class="button-group">
                <button id="download-frames-btn" class="action-btn">下载所有帧图</button>
                <button id="download-zip-btn" class="action-btn">下载为ZIP</button>
            </div>
        </div>
    </div>
</body>
</html>
