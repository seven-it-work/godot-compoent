# 执行计划

## 1. 需求分析

* 将 `minions_tier2.json` 中的卡牌数据转换为 TypeScript 文件

* 遵循 `Beetle.ts` 的文件结构

* 类名为卡牌名称的驼峰形式

* `inTavern` 属性：主卡牌为 `true`，token卡牌为 `false`

* BASE\_DATA 直接从JSON获取，包含tokens数组

* 文件夹根据卡牌的 minionTypes 第一个元素确定

* token卡牌单独生成文件，法术token放入spell文件夹

## 2. 实现步骤

### 2.1 编写Python脚本

* **脚本功能**：读取JSON文件，生成对应的TypeScript文件

* **核心逻辑**：

  * 遍历JSON中的每个卡牌

  * 生成主卡牌的TypeScript文件

  * 处理卡牌的tokens数组，生成每个token的TypeScript文件

  * 确保文件夹结构正确

### 2.2 脚本流程

1. 读取 `minions_tier2.json` 文件
2. 对于每个卡牌：

   * 生成主卡牌的TypeScript文件：

     * 类名：卡牌名称的驼峰形式

     * `inTavern: true`

     * BASE\_DATA包含完整的卡牌数据

     * 放入 `minions/{minionType}` 文件夹

   * 如果卡牌有tokens数组：

     * 遍历每个token：

       * 生成token的TypeScript文件：

         * 类名：token名称的驼峰形式

         * `inTavern: false`

         * 法术token放入 `spell` 文件夹

         * 随从token放入 `minions/{tokenMinionType}` 文件夹

### 2.3 文件模板

```typescript
import { Minion, minion_utils } from '@/server/controller/entity/Minion';

/**
 * {nameCN}类 - 继承自Minion，实现{nameCN}随从
 */
export class {className} extends Minion {
  inTavern: boolean = {inTavernValue};

  constructor() {
    super();
    minion_utils.initMinionData(this, BASE_DATA);
  }
}

const BASE_DATA = {jsonData};
```

### 2.4 关键函数

* `camel_case()`：将字符串转换为驼峰形式

* `ensure_folder_exists()`：确保目标文件夹存在

* `generate_ts_content()`：生成TypeScript文件内容

* `write_ts_file()`：写入TypeScript文件

## 3. 输出示例

* 主卡牌 `Sellemental.ts` 放入 `elemental` 文件夹

* token卡牌 `WaterDroplet.ts` 放入 `elemental` 文件夹

* 法术token放入 `spell` 文件夹

## 4. 运行脚本

* 脚本将在指定目录生成所有TypeScript文件

* 保持原有文件结构不变

* 生成的文件可直接用于项目开发

